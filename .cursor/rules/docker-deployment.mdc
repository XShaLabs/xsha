---
globs: Dockerfile*,docker-compose*.yml,docker/**/*
---
# Docker Deployment Patterns

## Multi-Stage Build Architecture

### Dockerfile Structure
The project uses a 3-stage Docker build process in [Dockerfile](mdc:Dockerfile):

1. **Frontend Builder Stage**: Node.js environment for React build
2. **Backend Builder Stage**: Go environment for binary compilation  
3. **Runtime Stage**: Minimal Alpine Linux for production

### Frontend Build Stage
```dockerfile
FROM node:20-alpine AS frontend-builder
RUN npm install -g pnpm
WORKDIR /app/frontend
COPY frontend/package.json frontend/pnpm-lock.yaml ./
RUN pnpm i
COPY frontend/ .
RUN pnpm run build
```

**Key Patterns**:
- Use Alpine images for smaller size
- Install pnpm for faster package management
- Copy package files first for better Docker layer caching
- Build outputs to `../backend/static` for embedded serving

### Backend Build Stage
```dockerfile
FROM golang:1.23.1-alpine AS backend-builder
RUN apk add --no-cache git ca-certificates tzdata gcc musl-dev sqlite-dev
WORKDIR /app
COPY backend/go.mod backend/go.sum ./
RUN go mod download && go mod verify
COPY backend/ .
COPY --from=frontend-builder /app/backend/static ./static
RUN CGO_ENABLED=1 go build -ldflags="-w -s" -o main .
```

**Key Patterns**:
- Enable CGO for SQLite support
- Use build-time optimizations: `-ldflags="-w -s"`
- Copy frontend build artifacts before Go build
- Verify dependencies with `go mod verify`

### Runtime Stage
```dockerfile
FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata curl docker-cli sqlite
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup
USER appuser
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1
```

**Key Patterns**:
- Minimal Alpine base for security and size
- Non-root user for security
- Health checks for container monitoring
- Docker CLI included for task execution

## Docker Compose Configuration

### Standard Deployment ([docker-compose.yml](mdc:docker-compose.yml))
```yaml
services:
  xsha-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - ENVIRONMENT=production
    volumes:
      - ./runtime/db:/app/runtime/db
      - ./runtime/workspaces:/app/runtime/workspaces
      - /var/run/docker.sock:/var/run/docker.sock
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### China-Optimized Deployment ([docker-compose.cn.yml](mdc:docker-compose.cn.yml))
- Uses Chinese registry mirrors: `m.daocloud.io/docker.io/library/`
- Same configuration as standard deployment
- Optimized for Chinese network conditions

## Volume Management

### Persistent Data
- **Database**: `./runtime/db` - SQLite database files
- **Workspaces**: `./runtime/workspaces` - Task execution workspaces
- **Docker Socket**: `/var/run/docker.sock` - For container orchestration

### Volume Patterns
```yaml
volumes:
  - ./runtime/db:/app/runtime/db          # Database persistence
  - ./runtime/workspaces:/app/runtime/workspaces  # Workspace persistence
  - /var/run/docker.sock:/var/run/docker.sock     # Docker API access
```

## Environment Configuration

### Production Environment Variables
```yaml
environment:
  - ENVIRONMENT=production
  - DB_TYPE=sqlite
  - DB_PATH=/app/runtime/db/xsha.db
  - WORKSPACE_BASE_DIR=/app/runtime/workspaces
  - JWT_SECRET=${JWT_SECRET}
  - PORT=8080
```

### Development Overrides
- Use `docker-compose.override.yml` for development-specific settings
- Mount source code volumes for hot reloading during development
- Use different port mappings if needed

## Container Orchestration Patterns

### Service Dependencies
```yaml
depends_on:
  - database  # If using external database
  - redis     # If using Redis for caching
```

### Network Configuration
```yaml
networks:
  default:
    driver: bridge
```

### Resource Limits
```yaml
deploy:
  resources:
    limits:
      memory: 1G
      cpus: '0.5'
    reservations:
      memory: 512M
      cpus: '0.25'
```

## Health Check Patterns

### Application Health Check
```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1
```

### Docker Compose Health Check
```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 40s
```

## Security Patterns

### Non-Root User
```dockerfile
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup
USER appuser
```

### File Permissions
```dockerfile
COPY --from=backend-builder /app/main .
RUN chown -R appuser:appgroup /app
```

### Docker Socket Security
- Mount Docker socket read-only when possible
- Use Docker API for container management
- Implement proper access controls

## Development Patterns

### Development Override
Create `docker-compose.override.yml` for development:
```yaml
services:
  xsha-app:
    build:
      dockerfile: Dockerfile
      target: backend-builder  # Stop at build stage for development
    volumes:
      - ./backend:/app
      - ./frontend/dist:/app/static
    environment:
      - ENVIRONMENT=development
      - GIN_MODE=debug
```

### Hot Reloading
- Use volume mounts for source code
- Install air for Go hot reloading
- Use Vite dev server for frontend development

## Deployment Best Practices

### Image Optimization
- Use multi-stage builds to minimize final image size
- Leverage Docker layer caching with proper COPY order
- Use `.dockerignore` to exclude unnecessary files

### Production Deployment
- Use specific image tags, not `latest`
- Implement proper logging and monitoring
- Use container orchestration platforms (Kubernetes, Docker Swarm)
- Implement rolling updates for zero-downtime deployments

### Monitoring and Logging
```yaml
logging:
  driver: "json-file"
  options:
    max-size: "10m"
    max-file: "3"
```

### Backup Strategies
- Regular backup of `./runtime/db` directory
- Version control for configuration files
- Database backup automation for production