---
description: "Database design and GORM patterns"
---

# Database Patterns

XSHA uses GORM with clean database patterns for maintainable data access.

## Model Definition

### Standard Model Structure
All models in [database/models.go](mdc:backend/database/models.go) follow this pattern:

```go
type ModelName struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
    
    // Model-specific fields
    Name        string `gorm:"not null" json:"name"`
    Description string `gorm:"type:text" json:"description"`
    
    // Foreign keys and relationships
    UserID uint `gorm:"not null;index" json:"user_id"`
    User   *User `gorm:"foreignKey:UserID" json:"user"`
}
```

### Key Conventions
- **Primary Key**: Always use `uint` with `gorm:"primarykey"`
- **Timestamps**: Include CreatedAt, UpdatedAt, DeletedAt for soft deletes
- **JSON Tags**: Match field names with snake_case for API responses
- **Indexes**: Add `index` tag for frequently queried fields
- **Relationships**: Define foreign keys and associations properly

## Field Types and Constraints

### Common Field Types
```go
// Text fields
Name        string `gorm:"not null" json:"name"`
Description string `gorm:"type:text" json:"description"`
Content     string `gorm:"type:longtext;not null" json:"content"`

// Enums using custom types
Status TaskStatus `gorm:"not null;index" json:"status"`
Type   GitCredentialType `gorm:"not null;index" json:"type"`

// Numeric fields
CPULimit    float64 `gorm:"default:1.0" json:"cpu_limit"`
MemoryLimit int64   `gorm:"default:1024" json:"memory_limit"`
CostUsd     float64 `gorm:"type:decimal(10,6);not null;default:0" json:"total_cost_usd"`

// Boolean fields
Success     bool `gorm:"not null;index" json:"success"`
IsEditable  bool `gorm:"not null;default:true" json:"is_editable"`

// Time fields
ExecutionTime *time.Time `gorm:"index" json:"execution_time"`
StartedAt     *time.Time `json:"started_at"`

// JSON exclusion for sensitive data
PasswordHash string `gorm:"type:text" json:"-"`
PrivateKey   string `gorm:"type:text" json:"-"`
```

### Enum Definitions
```go
type TaskStatus string

const (
    TaskStatusTodo       TaskStatus = "todo"
    TaskStatusInProgress TaskStatus = "in_progress"
    TaskStatusDone       TaskStatus = "done"
    TaskStatusCancelled  TaskStatus = "cancelled"
)
```

## Relationships

### Foreign Key Patterns
```go
// One-to-Many
type Project struct {
    ID    uint   `gorm:"primarykey"`
    Name  string `gorm:"not null"`
    Tasks []Task `gorm:"foreignKey:ProjectID"`
}

type Task struct {
    ID        uint     `gorm:"primarykey"`
    Title     string   `gorm:"not null"`
    ProjectID uint     `gorm:"not null;index"`
    Project   *Project `gorm:"foreignKey:ProjectID"`
}

// Optional Foreign Key
type Task struct {
    DevEnvironmentID *uint           `gorm:"index"`
    DevEnvironment   *DevEnvironment `gorm:"foreignKey:DevEnvironmentID"`
}

// Many-to-Many (if needed)
type User struct {
    ID       uint      `gorm:"primarykey"`
    Projects []Project `gorm:"many2many:user_projects;"`
}
```

## Repository Pattern

### Repository Interface
```go
// repository/interfaces.go
type TaskRepository interface {
    Create(task *database.Task) error
    GetByID(id uint) (*database.Task, error)
    Update(task *database.Task) error
    Delete(id uint) error
    List(filters TaskFilters) ([]database.Task, error)
    GetByProjectID(projectID uint) ([]database.Task, error)
}
```

### Repository Implementation
```go
// repository/task.go
type taskRepository struct {
    db *gorm.DB
}

func NewTaskRepository(db *gorm.DB) TaskRepository {
    return &taskRepository{db: db}
}

func (r *taskRepository) Create(task *database.Task) error {
    return r.db.Create(task).Error
}

func (r *taskRepository) GetByID(id uint) (*database.Task, error) {
    var task database.Task
    err := r.db.Preload("Project").Preload("DevEnvironment").First(&task, id).Error
    if err != nil {
        return nil, err
    }
    return &task, nil
}

func (r *taskRepository) List(filters TaskFilters) ([]database.Task, error) {
    query := r.db.Model(&database.Task{}).
        Preload("Project").
        Preload("DevEnvironment")
    
    if filters.Status != "" {
        query = query.Where("status = ?", filters.Status)
    }
    
    if filters.ProjectID != 0 {
        query = query.Where("project_id = ?", filters.ProjectID)
    }
    
    var tasks []database.Task
    err := query.Find(&tasks).Error
    return tasks, err
}
```

## Database Migrations

### Migration Strategy
- GORM auto-migration for development
- Manual migrations for production
- Version control for schema changes

```go
// database/database.go
func (dm *DatabaseManager) Migrate() error {
    return dm.db.AutoMigrate(
        &database.TokenBlacklist{},
        &database.LoginLog{},
        &database.GitCredential{},
        &database.Project{},
        &database.DevEnvironment{},
        &database.Task{},
        &database.TaskConversation{},
        &database.TaskExecutionLog{},
        &database.TaskConversationResult{},
        &database.AdminOperationLog{},
        &database.SystemConfig{},
    )
}
```

## Query Patterns

### Eager Loading
```go
// Load related data efficiently
var tasks []database.Task
err := db.Preload("Project").Preload("DevEnvironment").Find(&tasks).Error

// Conditional preloading
err := db.Preload("Project", "status = ?", "active").Find(&tasks).Error
```

### Complex Queries
```go
// Joins and aggregations
var result []struct {
    ProjectID   uint
    TaskCount   int64
    ActiveTasks int64
}

err := db.Model(&database.Task{}).
    Select("project_id, COUNT(*) as task_count, COUNT(CASE WHEN status = 'in_progress' THEN 1 END) as active_tasks").
    Group("project_id").
    Find(&result).Error
```

### Transactions
```go
func (r *taskRepository) CreateWithConversation(task *database.Task, conversation *database.TaskConversation) error {
    return r.db.Transaction(func(tx *gorm.DB) error {
        if err := tx.Create(task).Error; err != nil {
            return err
        }
        
        conversation.TaskID = task.ID
        if err := tx.Create(conversation).Error; err != nil {
            return err
        }
        
        return nil
    })
}
```

## Indexing Strategy

### Index Guidelines
```go
// Single column indexes
Username string `gorm:"not null;index" json:"username"`
Status   string `gorm:"not null;index" json:"status"`

// Composite indexes (define in migration)
// CREATE INDEX idx_tasks_project_status ON tasks(project_id, status);

// Unique indexes
Email string `gorm:"uniqueIndex;not null" json:"email"`
Token string `gorm:"uniqueIndex;not null" json:"token"`

// Partial indexes for soft deletes
DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
```

## Data Validation

### Model Validation
```go
// Use GORM hooks for validation
func (t *Task) BeforeCreate(tx *gorm.DB) error {
    if t.Title == "" {
        return errors.New("task title is required")
    }
    if t.ProjectID == 0 {
        return errors.New("project ID is required")
    }
    return nil
}
```

### Database Constraints
```go
// Not null constraints
Name string `gorm:"not null" json:"name"`

// Default values
Status TaskStatus `gorm:"not null;default:'todo'" json:"status"`

// Check constraints (database level)
CPULimit float64 `gorm:"check:cpu_limit > 0" json:"cpu_limit"`
```

## Performance Considerations

### Query Optimization
- Use appropriate indexes for frequent queries
- Limit result sets with pagination
- Use select to fetch only needed columns
- Avoid N+1 queries with proper preloading

### Connection Management
```go
// database/database.go
func NewDatabaseManager(cfg *config.Config) (*DatabaseManager, error) {
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    
    if err != nil {
        return nil, err
    }
    
    sqlDB, err := db.DB()
    if err != nil {
        return nil, err
    }
    
    // Connection pool settings
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)
    
    return &DatabaseManager{db: db}, nil
}
```

Always follow these patterns for consistent and maintainable database operations.