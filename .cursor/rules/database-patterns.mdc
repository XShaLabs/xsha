# Database Patterns and GORM Conventions

Database layer patterns for the Sleep0 project using GORM ORM.

## Model Definition ([backend/database/models.go](mdc:backend/database/models.go))

**Base Structure**: All models inherit standard GORM fields:

```go
type SomeModel struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
    
    // Model-specific fields
}
```

**Key Conventions**:
- Use `gorm.DeletedAt` for soft deletes
- Include `json:"-"` for `DeletedAt` to hide from API responses
- Use appropriate GORM tags for constraints and indexes
- Use typed constants for enums

## Relationship Patterns

**Foreign Key Relationships**:
```go
type Task struct {
    // Foreign key
    ProjectID uint     `gorm:"not null;index" json:"project_id"`
    // Association
    Project   *Project `gorm:"foreignKey:ProjectID" json:"project"`
}
```

**User Isolation Pattern**:
All user-scoped models include `CreatedBy` field:
```go
CreatedBy string `gorm:"not null;index;uniqueIndex:idx_name_user" json:"created_by"`
```

**Composite Indexes** for user isolation:
```go
Name      string `gorm:"not null;uniqueIndex:idx_name_user" json:"name"`
CreatedBy string `gorm:"not null;index;uniqueIndex:idx_name_user" json:"created_by"`
```

## Repository Implementation Patterns

**Standard CRUD Methods**:
```go
func (r *someRepository) Create(entity *database.SomeModel) error {
    return r.db.Create(entity).Error
}

func (r *someRepository) GetByID(id uint, createdBy string) (*database.SomeModel, error) {
    var entity database.SomeModel
    err := r.db.Where("id = ? AND created_by = ?", id, createdBy).First(&entity).Error
    if err != nil {
        return nil, err
    }
    return &entity, nil
}

func (r *someRepository) List(createdBy string, page, pageSize int) ([]database.SomeModel, int64, error) {
    var entities []database.SomeModel
    var total int64
    
    query := r.db.Where("created_by = ?", createdBy)
    
    // Count total
    query.Model(&database.SomeModel{}).Count(&total)
    
    // Get page
    offset := (page - 1) * pageSize
    err := query.Offset(offset).Limit(pageSize).Find(&entities).Error
    
    return entities, total, err
}
```

## Query Patterns

**User Isolation**: Always filter by `created_by`:
```go
r.db.Where("created_by = ?", createdBy).Find(&entities)
```

**Associations**: Use `Preload` for related data:
```go
r.db.Preload("Project").Preload("DevEnvironment").Find(&tasks)
```

**Pagination**: Consistent offset/limit pattern:
```go
offset := (page - 1) * pageSize
query.Offset(offset).Limit(pageSize).Find(&entities)
```

**Filtering with Pointers**: Handle optional filters:
```go
if status != nil {
    query = query.Where("status = ?", *status)
}
```

## Migration and Schema

**Auto-Migration** in [database.go](mdc:backend/database/database.go):
```go
db.AutoMigrate(
    &database.TokenBlacklist{},
    &database.LoginLog{},
    &database.GitCredential{},
    // ... all models
)
```

**Constraints**: Use GORM tags for database constraints:
- `not null`: Required fields
- `uniqueIndex`: Unique constraints
- `index`: Performance indexes
- `foreignKey`: Relationship definitions

## Encryption for Sensitive Data

For sensitive fields like passwords and SSH keys:

```go
// Before create/update
encryptedData, err := utils.Encrypt(sensitiveData, config.AESKey)

// In model
PasswordHash string `gorm:"type:text" json:"-"`          // Encrypted
PublicKey    string `gorm:"type:text" json:"public_key"` // Not sensitive
```

**Key Pattern**: Sensitive fields use `json:"-"` tag to exclude from JSON serialization.
---
globs: backend/database/**,backend/repository/**
---
