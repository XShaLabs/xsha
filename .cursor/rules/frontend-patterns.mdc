---
globs: frontend/**/*.{ts,tsx,js,jsx}
---

# React/TypeScript Frontend Patterns

Follow these patterns when working with the XSHA frontend.

## Component Organization

### 1. Component Structure
- UI components in [components/ui/](mdc:frontend/src/components/ui/) (shadcn/ui)
- Feature components in [components/](mdc:frontend/src/components/)
- Page components in [pages/](mdc:frontend/src/pages/)
- Layout components in [components/layouts/](mdc:frontend/src/components/layouts/)

### 2. Component Patterns

```tsx
// Use TypeScript for all components
interface ComponentProps {
  title: string;
  onAction?: () => void;
}

export function Component({ title, onAction }: ComponentProps) {
  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">{title}</h2>
      {onAction && (
        <Button onClick={onAction}>Action</Button>
      )}
    </div>
  );
}
```

## State Management

### 1. React Hooks
- Use custom hooks in [hooks/](mdc:frontend/src/hooks/)
- Group related state and logic
- Example: [hooks/useTaskConversations.ts](mdc:frontend/src/hooks/useTaskConversations.ts)

### 2. Context for Global State
- Authentication: [contexts/AuthContext.tsx](mdc:frontend/src/contexts/AuthContext.tsx)
- Navigation: [contexts/BreadcrumbContext.tsx](mdc:frontend/src/contexts/BreadcrumbContext.tsx)

## API Integration

### 1. API Client
- Centralized API client in [lib/api/](mdc:frontend/src/lib/api/)
- Type-safe request/response handling
- Consistent error handling

```tsx
// Example API function
export async function getTasks(): Promise<Task[]> {
  const response = await apiClient.get<Task[]>('/tasks');
  return response.data;
}
```

### 2. Data Fetching Patterns
```tsx
function TaskList() {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchTasks() {
      try {
        const data = await getTasks();
        setTasks(data);
      } catch (err) {
        setError('Failed to fetch tasks');
      } finally {
        setLoading(false);
      }
    }
    
    fetchTasks();
  }, []);

  if (loading) return <Skeleton />;
  if (error) return <Alert variant="destructive">{error}</Alert>;
  
  return <TaskTable tasks={tasks} />;
}
```

## Form Handling

### 1. Form Components
- Use components from [components/forms/](mdc:frontend/src/components/forms/)
- Consistent validation and error handling
- Example: [components/forms/BasicFormFields.tsx](mdc:frontend/src/components/forms/BasicFormFields.tsx)

### 2. Form Patterns
```tsx
interface FormData {
  name: string;
  description: string;
}

function ProjectForm() {
  const [formData, setFormData] = useState<FormData>({
    name: '',
    description: ''
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await createProject(formData);
      // Handle success
    } catch (error) {
      // Handle error
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        placeholder="Project name"
      />
      <Button type="submit">Create Project</Button>
    </form>
  );
}
```

## Styling

### 1. TailwindCSS
- Use utility classes for styling
- Follow consistent spacing (space-y-4, space-x-2, etc.)
- Use design system values

### 2. Component Variants
```tsx
import { cn } from "@/lib/utils";

interface ButtonProps {
  variant?: 'default' | 'destructive' | 'outline';
  size?: 'sm' | 'md' | 'lg';
}

function Button({ variant = 'default', size = 'md', className, ...props }: ButtonProps) {
  return (
    <button
      className={cn(
        "inline-flex items-center justify-center rounded-md font-medium",
        {
          'bg-primary text-primary-foreground': variant === 'default',
          'bg-destructive text-destructive-foreground': variant === 'destructive',
        },
        className
      )}
      {...props}
    />
  );
}
```

## Type Safety

### 1. TypeScript Types
- Define types in [types/](mdc:frontend/src/types/)
- Match backend model structures
- Use proper TypeScript conventions

### 2. API Response Types
```tsx
interface ApiResponse<T> {
  data: T;
  message?: string;
  error?: string;
}

interface Task {
  id: number;
  title: string;
  status: 'todo' | 'in_progress' | 'done' | 'cancelled';
  created_at: string;
  updated_at: string;
}
```

## Internationalization

- Use react-i18next for translations
- Translation files in [i18n/locales/](mdc:frontend/src/i18n/locales/)
- Always use translation keys, never hardcoded text

```tsx
import { useTranslation } from 'react-i18next';

function TaskCard() {
  const { t } = useTranslation('tasks');
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>{t('title')}</CardTitle>
      </CardHeader>
    </Card>
  );
}
```

Always prioritize type safety, accessibility, and consistent patterns.