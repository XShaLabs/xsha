---
description: "Error handling patterns and i18n error messages"
---

# Error Handling

XSHA implements comprehensive error handling with internationalization support.

## Error Types and Structure

### Custom Error Types
Located in [errors/i18n_error.go](mdc:backend/errors/i18n_error.go):

```go
type I18nError struct {
    Key     string                 `json:"key"`
    Code    string                 `json:"code"`
    Message string                 `json:"message"`
    Args    map[string]interface{} `json:"args,omitempty"`
    Cause   error                  `json:"-"`
}

func (e *I18nError) Error() string {
    return e.Message
}

// Constructor functions
func NewI18nError(key, code, defaultMessage string, args map[string]interface{}) *I18nError {
    return &I18nError{
        Key:     key,
        Code:    code,
        Message: defaultMessage,
        Args:    args,
    }
}
```

### Error Categories
```go
// Validation errors
var (
    ErrValidationFailed = NewI18nError("validation.failed", "VALIDATION_FAILED", "Validation failed", nil)
    ErrFieldRequired    = NewI18nError("validation.required", "FIELD_REQUIRED", "Field is required", nil)
    ErrInvalidFormat    = NewI18nError("validation.format", "INVALID_FORMAT", "Invalid format", nil)
)

// Authentication errors
var (
    ErrUnauthorized     = NewI18nError("auth.unauthorized", "UNAUTHORIZED", "Unauthorized access", nil)
    ErrInvalidToken     = NewI18nError("auth.invalid_token", "INVALID_TOKEN", "Invalid token", nil)
    ErrTokenExpired     = NewI18nError("auth.token_expired", "TOKEN_EXPIRED", "Token expired", nil)
)

// Resource errors
var (
    ErrNotFound         = NewI18nError("resource.not_found", "NOT_FOUND", "Resource not found", nil)
    ErrAlreadyExists    = NewI18nError("resource.exists", "ALREADY_EXISTS", "Resource already exists", nil)
    ErrCannotDelete     = NewI18nError("resource.cannot_delete", "CANNOT_DELETE", "Cannot delete resource", nil)
)
```

## Backend Error Handling

### Service Layer Error Handling
```go
// services/project.go
func (s *projectService) CreateProject(req CreateProjectRequest) (*database.Project, error) {
    // Validation
    if req.Name == "" {
        return nil, errors.NewI18nError(
            "validation.project_name_required",
            "PROJECT_NAME_REQUIRED",
            "Project name is required",
            nil,
        )
    }
    
    // Check for duplicates
    existing, err := s.repo.GetByName(req.Name)
    if err == nil && existing != nil {
        return nil, errors.NewI18nError(
            "validation.project_name_exists",
            "PROJECT_NAME_EXISTS",
            "Project with this name already exists",
            map[string]interface{}{"name": req.Name},
        )
    }
    
    // Business logic
    project := &database.Project{
        Name:        req.Name,
        Description: req.Description,
        RepoURL:     req.RepoURL,
        CreatedBy:   req.CreatedBy,
    }
    
    if err := s.repo.Create(project); err != nil {
        return nil, fmt.Errorf("failed to create project: %w", err)
    }
    
    return project, nil
}
```

### Handler Error Responses
```go
// handlers/project.go
func (h *ProjectHandlers) CreateProject(c *gin.Context) {
    var req CreateProjectRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request format",
            "details": err.Error(),
        })
        return
    }
    
    project, err := h.service.CreateProject(req)
    if err != nil {
        // Handle different error types
        var i18nErr *errors.I18nError
        if errors.As(err, &i18nErr) {
            // Translate error message
            message := h.i18n.Translate(c, i18nErr.Key, i18nErr.Args)
            
            // Determine status code based on error code
            statusCode := http.StatusInternalServerError
            switch i18nErr.Code {
            case "VALIDATION_FAILED", "PROJECT_NAME_REQUIRED":
                statusCode = http.StatusBadRequest
            case "PROJECT_NAME_EXISTS":
                statusCode = http.StatusConflict
            case "UNAUTHORIZED":
                statusCode = http.StatusUnauthorized
            case "NOT_FOUND":
                statusCode = http.StatusNotFound
            }
            
            c.JSON(statusCode, gin.H{
                "error": message,
                "code": i18nErr.Code,
            })
            return
        }
        
        // Generic error handling
        utils.Error("Failed to create project", "error", err)
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Internal server error",
        })
        return
    }
    
    c.JSON(http.StatusCreated, gin.H{
        "data": project,
        "message": h.i18n.Translate(c, "project.created_successfully", nil),
    })
}
```

### Error Middleware
Located in [middleware/error.go](mdc:backend/middleware/error.go):

```go
func ErrorHandlerMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                utils.Error("Panic recovered", "error", err, "path", c.Request.URL.Path)
                
                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": "Internal server error",
                    "code": "INTERNAL_ERROR",
                })
                c.Abort()
            }
        }()
        
        c.Next()
        
        // Handle errors set during request processing
        if len(c.Errors) > 0 {
            err := c.Errors.Last()
            utils.Error("Request error", "error", err.Err, "path", c.Request.URL.Path)
            
            c.JSON(http.StatusInternalServerError, gin.H{
                "error": "Internal server error",
                "code": "INTERNAL_ERROR",
            })
        }
    }
}
```

## Frontend Error Handling

### API Error Types
```tsx
// types/api.ts
interface ApiError {
  error: string;
  code?: string;
  details?: Record<string, string[]>;
}

interface ApiResponse<T> {
  data?: T;
  error?: string;
  code?: string;
  message?: string;
}
```

### Error Handling in API Client
```tsx
// lib/api/request.ts
export class ApiClient {
  private async handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
      const errorData: ApiError = await response.json();
      
      // Create structured error
      const error = new ApiError(
        errorData.error || 'Unknown error',
        response.status,
        errorData.code,
        errorData.details
      );
      
      throw error;
    }
    
    return response.json();
  }
  
  async get<T>(url: string): Promise<T> {
    try {
      const response = await fetch(this.baseURL + url, {
        headers: this.getHeaders(),
      });
      return this.handleResponse<T>(response);
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError('Network error', 0);
    }
  }
}

export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string,
    public details?: Record<string, string[]>
  ) {
    super(message);
    this.name = 'ApiError';
  }
}
```

### Component Error Handling
```tsx
// components/ProjectForm.tsx
function ProjectForm() {
  const [error, setError] = useState<string | null>(null);
  const [fieldErrors, setFieldErrors] = useState<Record<string, string[]>>({});
  const { t } = useTranslation();

  const handleSubmit = async (data: ProjectFormData) => {
    try {
      setError(null);
      setFieldErrors({});
      
      await createProject(data);
      
      // Success handling
      toast.success(t('project.created_successfully'));
    } catch (err) {
      if (err instanceof ApiError) {
        if (err.details) {
          // Field validation errors
          setFieldErrors(err.details);
        } else {
          // General error
          setError(err.message);
        }
      } else {
        setError(t('errors.unexpected_error'));
      }
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      <Input
        name="name"
        error={fieldErrors.name?.[0]}
        placeholder={t('project.name')}
      />
      
      <Button type="submit">
        {t('common.create')}
      </Button>
    </form>
  );
}
```

### Error Boundary
```tsx
// components/ErrorBoundary.tsx
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <Alert variant="destructive">
          <AlertTitle>Something went wrong</AlertTitle>
          <AlertDescription>
            An unexpected error occurred. Please refresh the page.
          </AlertDescription>
        </Alert>
      );
    }

    return this.props.children;
  }
}
```

## Logging and Monitoring

### Structured Logging
```go
// utils/logger.go
func Error(msg string, keysAndValues ...interface{}) {
    logger.Error(msg, keysAndValues...)
}

func Info(msg string, keysAndValues ...interface{}) {
    logger.Info(msg, keysAndValues...)
}

// Usage
utils.Error("Database connection failed", 
    "error", err,
    "host", cfg.DatabaseHost,
    "port", cfg.DatabasePort,
)
```

### Error Tracking
- Log all errors with context
- Include request ID for tracing
- Monitor error rates and patterns
- Alert on critical errors

## Error Translation

### Backend Translation
```go
// i18n/helper.go
func (h *I18nHelper) TranslateError(c *gin.Context, err error) string {
    var i18nErr *I18nError
    if errors.As(err, &i18nErr) {
        return h.Translate(c, i18nErr.Key, i18nErr.Args)
    }
    return err.Error()
}
```

### Frontend Translation
```tsx
// hooks/useErrorTranslation.ts
export function useErrorTranslation() {
  const { t } = useTranslation('errors');
  
  const translateError = (error: ApiError): string => {
    if (error.code) {
      const translationKey = `codes.${error.code.toLowerCase()}`;
      const translation = t(translationKey);
      
      // Return translation if found, otherwise fallback to message
      return translation !== translationKey ? translation : error.message;
    }
    
    return error.message;
  };
  
  return { translateError };
}
```

Always implement comprehensive error handling with proper logging and user-friendly messages.