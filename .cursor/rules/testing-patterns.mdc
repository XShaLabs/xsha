---
description: "Testing patterns and best practices for Go and TypeScript"
---

# Testing Patterns

Comprehensive testing guidelines for both backend (Go) and frontend (TypeScript/React) components.

## Go Backend Testing

### Test File Organization
```go
// project_service_test.go
package services

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "xsha-backend/database"
    "xsha-backend/repository/mocks"
)
```

### Test Structure Patterns
```go
func TestProjectService_CreateProject(t *testing.T) {
    // Arrange
    mockRepo := mocks.NewMockProjectRepository(t)
    service := NewProjectService(mockRepo, nil, nil)
    
    req := CreateProjectRequest{
        Name:        "test-project",
        Description: "Test description",
        RepoURL:     "https://github.com/test/repo",
        CreatedBy:   "testuser",
    }
    
    expectedProject := &database.Project{
        ID:          1,
        Name:        req.Name,
        Description: req.Description,
        RepoURL:     req.RepoURL,
        CreatedBy:   req.CreatedBy,
    }
    
    // Act & Assert
    mockRepo.EXPECT().
        Create(mock.MatchedBy(func(p *database.Project) bool {
            return p.Name == req.Name && p.RepoURL == req.RepoURL
        })).
        Return(nil).
        Once()
    
    result, err := service.CreateProject(req)
    
    // Assert
    assert.NoError(t, err)
    assert.NotNil(t, result)
    assert.Equal(t, req.Name, result.Name)
}
```

### Table-Driven Tests
```go
func TestProjectService_ValidateProject(t *testing.T) {
    tests := []struct {
        name          string
        project       *database.Project
        expectedValid bool
        expectedError string
    }{
        {
            name: "valid project",
            project: &database.Project{
                Name:    "valid-name",
                RepoURL: "https://github.com/user/repo",
            },
            expectedValid: true,
            expectedError: "",
        },
        {
            name: "missing name",
            project: &database.Project{
                RepoURL: "https://github.com/user/repo",
            },
            expectedValid: false,
            expectedError: "name is required",
        },
        {
            name: "invalid URL",
            project: &database.Project{
                Name:    "test",
                RepoURL: "invalid-url",
            },
            expectedValid: false,
            expectedError: "invalid repository URL",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            valid, err := validateProject(tt.project)
            
            assert.Equal(t, tt.expectedValid, valid)
            if tt.expectedError != "" {
                assert.Error(t, err)
                assert.Contains(t, err.Error(), tt.expectedError)
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

### Mock Patterns
```go
// Using testify/mock
type MockProjectRepository struct {
    mock.Mock
}

func (m *MockProjectRepository) Create(project *database.Project) error {
    args := m.Called(project)
    return args.Error(0)
}

func (m *MockProjectRepository) GetByID(id uint) (*database.Project, error) {
    args := m.Called(id)
    return args.Get(0).(*database.Project), args.Error(1)
}

// Test with mock
func TestProjectService_GetProject_NotFound(t *testing.T) {
    mockRepo := &MockProjectRepository{}
    service := NewProjectService(mockRepo, nil, nil)
    
    mockRepo.On("GetByID", uint(999)).Return((*database.Project)(nil), gorm.ErrRecordNotFound)
    
    result, err := service.GetProject(999)
    
    assert.Error(t, err)
    assert.Nil(t, result)
    mockRepo.AssertExpectations(t)
}
```

### HTTP Handler Testing
```go
func TestProjectHandlers_CreateProject(t *testing.T) {
    // Setup
    gin.SetMode(gin.TestMode)
    mockService := &MockProjectService{}
    handler := NewProjectHandlers(mockService)
    
    // Test data
    reqBody := CreateProjectRequest{
        Name:    "test-project",
        RepoURL: "https://github.com/test/repo",
    }
    
    expectedProject := &database.Project{
        ID:      1,
        Name:    reqBody.Name,
        RepoURL: reqBody.RepoURL,
    }
    
    // Setup mock
    mockService.On("CreateProject", reqBody).Return(expectedProject, nil)
    
    // Create request
    jsonData, _ := json.Marshal(reqBody)
    req := httptest.NewRequest("POST", "/projects", bytes.NewBuffer(jsonData))
    req.Header.Set("Content-Type", "application/json")
    
    // Create response recorder
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = req
    
    // Execute
    handler.CreateProject(c)
    
    // Assert
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(t, err)
    assert.NotNil(t, response["data"])
    
    mockService.AssertExpectations(t)
}
```

### Integration Testing
```go
func TestProjectIntegration(t *testing.T) {
    // Setup test database
    db := setupTestDB(t)
    defer db.Migrator().DropTable(&database.Project{})
    
    // Setup dependencies
    repo := repository.NewProjectRepository(db)
    service := services.NewProjectService(repo, nil, nil)
    
    // Test create
    req := CreateProjectRequest{
        Name:      "integration-test",
        RepoURL:   "https://github.com/test/repo",
        CreatedBy: "testuser",
    }
    
    project, err := service.CreateProject(req)
    assert.NoError(t, err)
    assert.NotZero(t, project.ID)
    
    // Test retrieve
    retrieved, err := service.GetProject(project.ID)
    assert.NoError(t, err)
    assert.Equal(t, project.Name, retrieved.Name)
}

func setupTestDB(t *testing.T) *gorm.DB {
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    assert.NoError(t, err)
    
    err = db.AutoMigrate(&database.Project{})
    assert.NoError(t, err)
    
    return db
}
```

## Frontend Testing

### Component Testing Setup
```tsx
// components/__tests__/ProjectForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { ProjectForm } from '../ProjectForm';
import * as api from '../../lib/api/projects';

// Mock API
vi.mock('../../lib/api/projects');
const mockCreateProject = vi.mocked(api.createProject);

// Mock i18n
vi.mock('react-i18next', () => ({
  useTranslation: () => ({
    t: (key: string) => key,
  }),
}));
```

### Component Unit Tests
```tsx
describe('ProjectForm', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  test('renders form fields correctly', () => {
    render(<ProjectForm onSuccess={vi.fn()} />);
    
    expect(screen.getByLabelText(/project name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/description/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/repository url/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /create/i })).toBeInTheDocument();
  });

  test('validates required fields', async () => {
    render(<ProjectForm onSuccess={vi.fn()} />);
    
    const submitButton = screen.getByRole('button', { name: /create/i });
    fireEvent.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText(/name is required/i)).toBeInTheDocument();
      expect(screen.getByText(/repository url is required/i)).toBeInTheDocument();
    });
  });

  test('submits form with valid data', async () => {
    const mockOnSuccess = vi.fn();
    const mockProject = { id: 1, name: 'Test Project', repo_url: 'https://github.com/test/repo' };
    
    mockCreateProject.mockResolvedValueOnce(mockProject);
    
    render(<ProjectForm onSuccess={mockOnSuccess} />);
    
    // Fill form
    fireEvent.change(screen.getByLabelText(/project name/i), {
      target: { value: 'Test Project' },
    });
    fireEvent.change(screen.getByLabelText(/repository url/i), {
      target: { value: 'https://github.com/test/repo' },
    });
    
    // Submit
    fireEvent.click(screen.getByRole('button', { name: /create/i }));
    
    await waitFor(() => {
      expect(mockCreateProject).toHaveBeenCalledWith({
        name: 'Test Project',
        repo_url: 'https://github.com/test/repo',
        description: '',
      });
      expect(mockOnSuccess).toHaveBeenCalledWith(mockProject);
    });
  });

  test('handles API errors', async () => {
    const mockError = new Error('Failed to create project');
    mockCreateProject.mockRejectedValueOnce(mockError);
    
    render(<ProjectForm onSuccess={vi.fn()} />);
    
    // Fill and submit form
    fireEvent.change(screen.getByLabelText(/project name/i), {
      target: { value: 'Test Project' },
    });
    fireEvent.change(screen.getByLabelText(/repository url/i), {
      target: { value: 'https://github.com/test/repo' },
    });
    fireEvent.click(screen.getByRole('button', { name: /create/i }));
    
    await waitFor(() => {
      expect(screen.getByText(/failed to create project/i)).toBeInTheDocument();
    });
  });
});
```

### Hook Testing
```tsx
// hooks/__tests__/useTaskConversations.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { useTaskConversations } from '../useTaskConversations';
import * as api from '../../lib/api/task-conversations';

vi.mock('../../lib/api/task-conversations');
const mockGetConversations = vi.mocked(api.getConversations);

describe('useTaskConversations', () => {
  test('fetches conversations on mount', async () => {
    const mockConversations = [
      { id: 1, content: 'Test conversation', status: 'pending' },
    ];
    
    mockGetConversations.mockResolvedValueOnce(mockConversations);
    
    const { result } = renderHook(() => useTaskConversations(1));
    
    expect(result.current.loading).toBe(true);
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.conversations).toEqual(mockConversations);
      expect(result.current.error).toBeNull();
    });
  });

  test('handles fetch errors', async () => {
    const mockError = new Error('Network error');
    mockGetConversations.mockRejectedValueOnce(mockError);
    
    const { result } = renderHook(() => useTaskConversations(1));
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.conversations).toEqual([]);
      expect(result.current.error).toBe('Network error');
    });
  });
});
```

### Integration Testing with React Testing Library
```tsx
// pages/__tests__/ProjectListPage.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { vi } from 'vitest';
import { ProjectListPage } from '../ProjectListPage';
import { AuthContext } from '../../contexts/AuthContext';

const renderWithProviders = (component: React.ReactElement) => {
  const mockAuthValue = {
    isAuthenticated: true,
    username: 'testuser',
    login: vi.fn(),
    logout: vi.fn(),
    loading: false,
  };

  return render(
    <BrowserRouter>
      <AuthContext.Provider value={mockAuthValue}>
        {component}
      </AuthContext.Provider>
    </BrowserRouter>
  );
};

describe('ProjectListPage', () => {
  test('displays loading state initially', () => {
    renderWithProviders(<ProjectListPage />);
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });

  test('displays projects after loading', async () => {
    const mockProjects = [
      { id: 1, name: 'Project 1', description: 'Description 1' },
      { id: 2, name: 'Project 2', description: 'Description 2' },
    ];

    vi.mocked(api.getProjects).mockResolvedValueOnce(mockProjects);

    renderWithProviders(<ProjectListPage />);

    await waitFor(() => {
      expect(screen.getByText('Project 1')).toBeInTheDocument();
      expect(screen.getByText('Project 2')).toBeInTheDocument();
    });
  });
});
```

### E2E Testing Patterns
```tsx
// e2e/project-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Project Management', () => {
  test.beforeEach(async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[name=username]', 'admin');
    await page.fill('[name=password]', 'password');
    await page.click('button[type=submit]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('creates a new project', async ({ page }) => {
    // Navigate to projects
    await page.click('text=Projects');
    await expect(page).toHaveURL('/projects');

    // Create new project
    await page.click('text=Create Project');
    await page.fill('[name=name]', 'E2E Test Project');
    await page.fill('[name=description]', 'Created by E2E test');
    await page.fill('[name=repo_url]', 'https://github.com/test/repo');
    await page.click('button[type=submit]');

    // Verify project created
    await expect(page.locator('text=E2E Test Project')).toBeVisible();
    await expect(page.locator('text=Project created successfully')).toBeVisible();
  });

  test('validates project form', async ({ page }) => {
    await page.goto('/projects');
    await page.click('text=Create Project');
    
    // Submit empty form
    await page.click('button[type=submit]');
    
    // Check validation errors
    await expect(page.locator('text=Project name is required')).toBeVisible();
    await expect(page.locator('text=Repository URL is required')).toBeVisible();
  });
});
```

## Testing Best Practices

### Test Naming Conventions
```go
// Go tests
func TestServiceName_MethodName_Scenario(t *testing.T) { }
func TestProjectService_CreateProject_Success(t *testing.T) { }
func TestProjectService_CreateProject_ValidationError(t *testing.T) { }

// TypeScript tests
describe('ComponentName', () => {
  test('should do something when condition', () => { });
  test('should handle error when API fails', () => { });
});
```

### Test Organization
```
backend/
  services/
    project_service.go
    project_service_test.go
  handlers/
    project_handler.go
    project_handler_test.go

frontend/src/
  components/
    ProjectForm.tsx
    __tests__/
      ProjectForm.test.tsx
  hooks/
    useProjects.ts
    __tests__/
      useProjects.test.ts
```

### Coverage Goals
- Aim for 80%+ code coverage
- Focus on critical business logic
- Test error paths and edge cases
- Prioritize integration tests for complex flows

### Mock Strategy
- Mock external dependencies (APIs, databases)
- Use real implementations for unit logic
- Keep mocks simple and focused
- Verify mock interactions

Always write tests that are maintainable, readable, and provide confidence in your code.