# Backend Development Patterns

## Clean Architecture Layers
Follow the established architecture pattern from [main.go](mdc:backend/main.go):

1. **Handlers** ([handlers/](mdc:backend/handlers/)) - HTTP request handling
2. **Services** ([services/](mdc:backend/services/)) - Business logic
3. **Repository** ([repository/](mdc:backend/repository/)) - Data access
4. **Models** ([database/models.go](mdc:backend/database/models.go)) - Data structures

## Handler Pattern
Follow the structure from [project.go](mdc:backend/handlers/project.go):

```go
// Handler struct with service injection
type ResourceHandlers struct {
    resourceService services.ResourceService
}

// Constructor function
func NewResourceHandlers(resourceService services.ResourceService) *ResourceHandlers {
    return &ResourceHandlers{resourceService: resourceService}
}

// Handler method pattern
func (h *ResourceHandlers) ActionHandler(c *gin.Context) {
    lang := middleware.GetLangFromContext(c)
    username, _ := c.Get("username")
    
    // Request validation
    var req RequestStruct
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": i18n.T(lang, "validation.invalid_format") + ": " + err.Error(),
        })
        return
    }
    
    // Business logic via service
    result, err := h.resourceService.Action(params)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": i18n.T(lang, "resource.action_failed") + ": " + err.Error(),
        })
        return
    }
    
    // Success response
    c.JSON(http.StatusOK, gin.H{
        "message": i18n.T(lang, "resource.action_success"),
        "data": result,
    })
}
```

## Service Pattern
Follow the dependency injection pattern from [auth.go](mdc:backend/services/auth.go):

```go
type resourceService struct {
    repo   repository.ResourceRepository
    config *config.Config
}

func NewResourceService(repo repository.ResourceRepository, cfg *config.Config) ResourceService {
    return &resourceService{repo: repo, config: cfg}
}
```

## Error Handling & Internationalization
- Always use `i18n.T(lang, "key")` for user-facing messages
- Extract language from context: `lang := middleware.GetLangFromContext(c)`
- Follow error response pattern from [error.go](mdc:backend/middleware/error.go)
- Add operation logging for important actions

## Request/Response Structs
- Define request structs with binding tags
- Include Swagger annotations for API documentation
- Use pointer types for optional fields (`*uint`, `*string`)
- Validate required vs optional fields

## Database Models
- Use GORM patterns from [models.go](mdc:backend/database/models.go)
- Include soft deletes with `gorm.DeletedAt`
- Add created/updated timestamps
- Use appropriate indexes and constraints
description:
globs:
alwaysApply: false
---
